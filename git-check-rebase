#!/usr/bin/env python3

import os
import sys
import tabulate
from typing import List, Optional, Type
from types import TracebackType

import compare_ranges
from check_rebase_meta import Meta
from span import Span
from compare_ranges import CommitRange, CompRes, parse_range
from compare_commits import interactive_compare_commits, \
    check_git_clean_branch
from tempfile import mkstemp

tabulate.PRESERVE_WHITESPACE = True


def print_legend(ranges, html):
    def_col = (
        ('bug-critical', 'Critical bugs'),
        ('matching', 'Matching, checked automatically'),
        ('checked', 'Matching, checked by hand'),
        ('drop', 'Dropped patches'),
        ('bug', 'Jira issues, non-critical')
    )
    br = '<br>' if html else ''
    for col, desc in def_col:
        print(Span(f'███████ - {desc}', klass=col))
    for r in ranges:
        if r.name != r.git_range:
            print('{} = {}{}'.format(r.name, r.git_range, br))


class GitCheckRebase:
    def __init__(self, range_defs, meta_path, html, jira, jira_issues, legend,
                 columns, rows, interactive, color, ignore_commit_messages):
        self.range_defs = range_defs
        self.jira = jira
        self.jira_issues = jira_issues
        self.legend = legend
        self.cols_full = columns == 'full'
        self.rows_full = rows == 'all'
        self.interactive = interactive
        self.ignore_commit_messages = ignore_commit_messages

        self.html = html
        if html:
            self.fmt = 'html'
        elif color is None:
            self.fmt = 'colored' if sys.stdout.isatty() else 'plain'
        else:
            self.fmt = 'colored' if self.color else 'plain'

        self.created_meta = not meta_path
        if self.created_meta:
            fd, meta_path = mkstemp()
            os.close(fd)

        self.meta = Meta(meta_path)

        _, self.right_range_base, _ = parse_range(self.range_defs[-1])
        if self.right_range_base is None:
            sys.exit('Last range must contain ".." separator. You shouldn\'t '
                     'want print the whole branch.')

    def __enter__(self):
        return self

    def __exit__(self,
                 exc_type: Optional[Type[BaseException]],
                 exc_value: Optional[BaseException],
                 traceback: Optional[TracebackType]) -> None:
        if self.created_meta:
            if os.stat(self.meta.fname).st_size == 0:
                os.unlink(self.meta.fname)
            else:
                print(f"""

Meta file is created: {self.meta.fname}
You may use it with next run, specifying option --meta {self.meta.fname}""")

    def parse_range_defs(self):
        """Must be called again, when git history changed"""
        self.ranges = [CommitRange(r, meta=self.meta,
                                   default_base=self.right_range_base)
                       for r in self.range_defs]

    def main(self, start_from):
        if start_from:
            if not self.interactive:
                sys.exit('--start_from supported only in --interactive mode')

        self.parse_range_defs()

        if self.jira_issues:
            assert self.jira is not None
            self.jira_issues = self.jira_issues.split(',')

        tab = compare_ranges.Table(self.ranges, self.meta)
        tab.do_comparison(self.ignore_commit_messages)
        if self.jira:
            tab.add_jira_info(self.jira, self.jira_issues)

        if self.interactive:
            branch = check_git_clean_branch()
            for row_ind, row in enumerate(tab.rows):
                if row.commits[0] is None:
                    base_ind = len(row.commits) - 1
                    other_inds = range(base_ind)
                else:
                    base_ind = 0
                    other_inds = range(1, len(row.commits))

                base = row.commits[base_ind]
                assert base is not None

                if start_from == base.commit_hash:
                    start_from = None

                if branch and self.ranges[base_ind].top in ('HEAD', branch):
                    base_rebase_branch = branch
                else:
                    base_rebase_branch = ''

                stop = False
                for i in other_inds:
                    c = row.commits[i]
                    if c is None:
                        continue

                    if start_from == c.commit_hash:
                        start_from = None
                    if start_from is not None:
                        continue
                    if branch and self.ranges[i].top in ('HEAD', branch):
                        c_rebase_branch = branch
                    else:
                        c_rebase_branch = ''

                    if c.comp != CompRes.NONE:
                        continue

                    if base_ind == 0:
                        a, b = base, c
                        a_br, b_br = base_rebase_branch, c_rebase_branch
                    else:
                        a, b = c, base
                        a_br, b_br = c_rebase_branch, base_rebase_branch

                    res = interactive_compare_commits(a.commit_hash,
                                                      b.commit_hash,
                                                      a_br, b_br,
                                                      c2_ind=row_ind+1,
                                                      comment=row.get_comment())
                    assert not res.equal  # that would be bug in compare_ranges
                    if res.ok:
                        ok_pair = a.commit_hash, b.commit_hash
                        base.comp = CompRes.BASE
                        c.comp = CompRes.CHECKED
                    else:
                        ok_pair = None
                    self.meta.update_meta(row.subject, res.comment, ok_pair)
                    if res.stop:
                        stop = True
                        break

                    restart_from = res.new_c1 or res.new_c2
                    if restart_from:
                        self.main(start_from=restart_from)
                        return
                if stop:
                    break

        out = tab.to_spans(fmt=self.fmt, headers=self.cols_full,
                           date_column=self.cols_full,
                           author_column=self.cols_full,
                           meta_column=self.cols_full,
                           rows_full=self.rows_full)

        if self.html:
            print("""<!DOCTYPE html>
                  <meta charset="utf-8"/>
                  <style>
                  body {
                     font-family: monospace;
                  }
                  </style>
                  """)

        if self.legend:
            print_legend(self.ranges, self.html)

        if self.html:
            tablefmt = 'html'
        elif self.legend:
            tablefmt = 'simple'
        else:
            tablefmt = 'plain'
        print(tabulate.tabulate(out, tablefmt=tablefmt))


if __name__ == '__main__':
    import argparse

    p = argparse.ArgumentParser(description="Compare git commit ranges")

    p.add_argument('ranges', metavar='range', nargs='+',
                   help='ranges to compare, '
                   'in form [<name>:]<git range or ref>')
    p.add_argument('--meta', help='optional, file with additional metadata')
    p.add_argument('--html', help='output in html format', action='store_true')
    p.add_argument('--jira-issues',
                   help='optional, comma-separated jira issues list')
    p.add_argument('--jira', help='user:password@server')
    p.add_argument('--legend', help='print legend', action='store_true')
    p.add_argument('--columns',
                   help='which columns to show in table: "short" is default. '
                   '"full" adds author and date columns and also column '
                   'headers', default='short')
    p.add_argument('--rows', choices=('all', 'short'),
                   help='which rows to show in table: "all" is default. '
                   '"short" omits rows where first column equal to the last '
                   'column', default='all')
    p.add_argument('--interactive',
                   help='do interactive comparison of not-equal commits. '
                   'For each commit to compare, vimdiff is started as a '
                   'subprocess. User should exit it successfully (by :qa) to '
                   'mark commits "ok", and with error (by :cq) to don\'t '
                   'mark commits "ok"', action='store_true')
    p.add_argument('--color',
                   help='Highlight results. By default does coloring only '
                   'when stdout is tty', action=argparse.BooleanOptionalAction,
                   default=None)
    p.add_argument('--ignore-commit-messages',
                   help='Ignore commit message when compare commits',
                   action='store_true')
    p.add_argument('--start-from', help='hash commit of right column to '
                   'start from for interactive check.')

    args = p.parse_args()

    try:
        gcr = GitCheckRebase(range_defs=args.ranges, meta_path=args.meta,
                             html=args.html,
                             jira=args.jira, jira_issues=args.jira_issues,
                             legend=args.legend, columns=args.columns,
                             rows=args.rows, interactive=args.interactive,
                             color=args.color,
                             ignore_commit_messages=args.ignore_commit_messages)
    except OSError as e:
        sys.exit(f'Failed to open "{args.meta}": {e.strerror}')

    with gcr:
        gcr.main(start_from=args.start_from)
